                17/05
- use custom ft_usleep : to stop prog when philo dies (don't wait for other philo to finish eating)
- print death in monitor in case 2 philos die
>> NOT WORKING + PB WITH pthread_join
>> HANDLE ALL ERROS THOROUGHLY
>> USE INDIVIDUAL MUTEXES FOR INDIV DATA (eating, meals_eaten, last_meal_time, dead)
>> USE COMMON MUTEXES FOR COMMON DATA
>>> dead flag changed : now common to all philos in data struct
>>> NOTHING PRINTED IN THREADS ?????!!!

                16/05
- timestamps ok
- fix data races
>> ADD 3rd STRUCT WITH GENERAL DATA NEEDED BY ALL (1 mutex for each resource, not each philo) - OK?
>>> in routine : START THINKING IF PAIR OU IF IMPAIR & FIRST/LAST PHILO
>> in take forks : take forks in different order if pair or impair, put down in reverse too
>>>>>> ADAPT CODE TO NEW STRUCTS (only init structs done)

                12/05
- data races, reverted to v2 ("v3")

                10/05
- compiles !
>> FIXING DATA RACE IN END_THREADS - OK
- seems to work for 1 philo (check timestamps?)
- if 2 philos : pb = no action for philo 2
> if 3 philos : action for 1 and 3
>> pb with usleep in routine - FIXED
- new pb : timestamp not ok for philo nÂ°1 - FIXED
>> PB WITH TIME
> check & fix printed timestamps
> check usleep times 

                09/05
- init thread ok >> check usleep TIME
- actions : check usleep TIME
- solo philo case >> CHECK
- death case & timing >> CHECK & adjust
- note : if even, time_to_die must be = time_to_eat + time_to_sleep + x (if odd, time_to_eat * 2)
>>> START TESTING
- INIT STRUCTS OK 
- THREADED FUNCTIONS NOT COMPILING >> WRONG ORDER >> STILL NOT WORKING
>> FOCUS : init_threads, actions, monitor

                08/05
- structs init done
>> USE MUTEX LOCK WHEN WRITING
- started monitoring
- threads created
- steps done : DO ACTIONS
TO DO :
>> monitor : handle exits (meals eaten & death) + monitor death with timestamp
>> actions : check usleep TIME
>> init_threads : check usleep 
(if (current_time - last_meal) > death_time ; then philo dead)
(check in main or in threads?)

                06/05
- struct draft created

                03/05
- checks done
- do PARSING : populate 2 structs
- watch tutos & learn about threads







                TO DO

- [ ] check time_to_die minimum
- [ ] check timestamps for 1 philo

- [ ] check time between philo death and msg printed 
- [ ] check odd/even numbers to adjust usleep in routine
- [ ] protect init_threads & monitor in main ? 
- [ ] check where to put start time (in philos or data struct?)
- [ ] protect pthread_join ?
- [ ] check if thread should be created for check_meals
- [ ] adjust times according to odd or even number of philos?













                FUNCTIONS
INIT
- [x] PARSE ARGS
- [x] INIT PHILOS
- [x] INIT_MUTEXES
- [x] GET_TIME

MONITOR
- [x] MONITOR PHILO DEATH
- [x] WAIT FOR THREADS
- [x] DESTROY MUTEXES
- [x] TIMESTAMP

ACTIONS
- [x] CREATE THREADS
- [x] PHILO EATS (>> take_fork())
- [x] PHILO SLEEPS
- [x] PHILO THINKS
- [x] PRINT ACTION




                PLAN ACTIONS : 
// THINK 
// - print msg

// SLEEP
// - print msg 
// - usleep

// EAT //take fork 1 THEN fork 2

// 1. TAKE FORKS
// - lock 1st fork
// - print msg (fork_taken)
// - handle solo case
// - lock 2nd fork 
// - print msg (fork_taken)

// 2. UPDATE STATUS
// - lock meal mutex
// - meals_eaten++
// - last_meal_time = get_time()
// - eating = 1
// unlock meal mutex

// 3. FINISH EATING
// - print msg (is eating)
// - usleep(eat_time)
// - eating = 0 // lock mutex here <<
// - unlock forks

















// all in ms :

// number_of_philosophers 
// time_to_die
// time_to_eat 
// time_to_sleep

// optional : number_of_times_each_philosopher_must_eat
 



1 thread / philo
1 fork / philo
1 mutex / fork (used to check/change fork value)
1 mutex to prevent that philo dies & starts eating simultaneously