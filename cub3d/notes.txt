1. INIT game (store textures in buf) + PARSE map

2. RAY CASTING

3. RENDERING
    > handle textures
    - calculate each pixel for a given ray
    > use mlx_new_image + mlx_get_data_addr
    > assign RGB value to a pixel (assign the colour to the pixel in the image buffer, and then draw the whole image to the screen at once)

4. Player MOVEMENT

INFO :
- NO : north texture
- SO : south texture
- WE : west texture
- EA : east texture
- F : floor color (RGB = 0, 255, 255)
- C : ceiling color (RGB)



        RAYCASTING ALGO
/*
0. CHECK UNIT CIRCLE
To rotate a point (x,y)(x,y) around the origin by an angle θθ,
	the new coordinates (x′,y′)(x′,y′) are computed using:
x′=x⋅cos⁡(θ)−y⋅sin⁡(θ)
x′=x⋅cos(θ)−y⋅sin(θ)
y′=x⋅sin⁡(θ)+y⋅cos⁡(θ)
y′=x⋅sin(θ)+y⋅cos(θ)

1. FIND ANGLE FOR FIRST RAY - OK
    - PA(p_x, p_y); angle; fov
    - angle = (PA/2) - (fov/2)

2. LOOP FOR EACH RAY - OK
    - fov = 60
    - cast S_W rays
    - i++ = curr (angle + fov) / S_W

3. GET HORIZONTAL INTERSECTION
    - calculate x & y pos for 1st intersection - OK
    - then, calculate x_step & y_step - OK
        > y_step = tile_size - OK
        > tile_size / tan(ray_angle) - OK

    - intersection points = (x_inter, y_inter) + use steps to move to next point
	- OK
        > y_inter = (p_y/tile_size) * tile_size - OK
        > x_inter= p_x + (y_inter - p_y) / tan(ray_angle) - OK

   
	- adjust steps according to player pos/angle (depending if facing down/right,
		down/left, up/left) <<

    - To ensure that the intersection is inside a map grid,
	we will add a pixel every time we check for a wall hit
        > use pixel variable - OK
    
   
	- then we just keep incrementing the intersection position by the steps and check if it hits the wall
	- OK

    - if wall : calculate the distance from the play_pos to intersect_pos - OK
        > find hypotenuse c :  c = sqrt(a^2 + b^2)
*/
