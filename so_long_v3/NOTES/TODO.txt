HELP : https://github.com/madebypixel02/so_long/blob/main/src/check.c 

            RESEARCH
- SYNC : https://harm-smits.github.io/42docs/libs/minilibx/sync.html
- LOOPS : https://harmless-canopy-b3a.notion.site/Les-boucles-c8eb0b92674a4926bdf3396786f61d59
- PROTOTYPES : https://harm-smits.github.io/42docs/libs/minilibx/prototypes.html#mlx_loop_hook
________________________________________________________________________________________________
                                    22/03
- score in trop left corner >> tearing (check string_put pos)
- moves not working >> check mlx_hook/mlx_loop_hook >> render_map (shuld redraw map at each move)

                                    21/03
- PB : can't display images
>> check mlx_xpm_file_to_img
>> try with png

NEXT STEP : display img

- check : not too large map
- wrong access


                                    15/03                                   
- window can be opened and closed
- NOW : trying to display img + render frames
                            
                                    14/03
- Valgrind errors & leaks fixed
- min.ber problem : doesn't fill 'E'
                                    
                                    10/03
LEAKS FIXED
- FIX conditional move or jump in flood_fill

>>> EXIT IS FLOOR <<<

                                    08/03
- CHECK PATH FIX OK
- FIX LEAKS >> for all maps OK
- FIX FLOOD_FILL for min.ber OK                                   
                                    
                                    07/03
- debugging check_map 
> SEGFAULT at print_map_error OK

- fix check_layout : (lay struct ok) OK
> err_check not OK for : inv_char - inv_walls - inv_row OK

- map_str not ok : initialized with "\U" ??? OK
_____________________________________________________________________________________________
                                    TESTS
           
            CHECK MAP
- [ ] check if invalid permissions
- [ ] map with too few columns/rows,
- [ ] empty line in the middle of the map
- [ ] min.ber flood_fill (check if E replaced by F)
- [x] non-rectangle map
- [x] invalid chars
- [x] double P or E
- [x] collectibles : none, plenty
- [x] walls
- [x] concatenation of map_str
- [x] check .ber w/ only '\n' 

            CHECK INPUT 
- [x] invalid args
- [x] invalid file
- [x] directory that ends with .ber
________________________________________________________________________________________________
                                    SUJET - CONSIGNES
GAME
- [ ] moves : W, A, S, D keys
- [ ] 4 directions possible (up, down, left, right)
- [ ] no moving into walls
- [ ] display curr number of moves in window OR terminal

GRAPHIC MANAGEMENT
- [ ] smooth window management (resizing...)
- [x] press ESC to close window & exit program
- [x] click on croix to close window
- [ ] use images of MiniLibX

MAP
- [x] at least 1 E, 1 C, 1 P
- [x] no other chars than 0, 1, C, E, P
- [x] rectangle map
- [x] valid map
- [x] file w/ .ber format

END
- [ ] no leaks <<< RUN MULTIPLE TESTS (empty, awkaward, big, small maps + check all errors)
- [ ] norm
________________________________________________________________________________________________
                                        STEPS   
OK 1. Parse : flood fill
    - is map valid (right letters, collectibes, exits, walls...)

2. Init (+ handle errors)
3. mlx & window

4. register hooks
5. load textures
6. render window
7. handle moves


COMMON MISTAKES
   - Rendering all textures in every frame. This uses up memory and after a (very long) while will cause your program to crash.
   - Not using constants to increase readability/maintainability. Although not a bug, it isn't a good habit to explicitly index into an array with a fixed number, use a plain string as an asset path, or repeat an arbitrary value as your tile size.
   - Edge cases for map checking. Think of invalid permissions, a map with too few columns/rows, or even an empty line in the middle of the map.
   - Going to the exit without all collectables should not end the game.

    HANDLING MOVES
When a player moves, there are two things you need to check:
    - Is the next move valid?
    - Does the next move cause a special event (either winning the game, collecting a collectable, or in the case of a bonus, hitting an enemy)?

________________________________________________________________________________________________
                                        MLX  

mlx_loop: Registers any previously defined hooks and listens. This also prevents the default behaviour of destroying the window upon creating it.
mlx_hook: Allows you to listen for native X11 events, such as mouse movements, key presses, window interaction, and more

REMINDERS:

1. CHECK ERRORS + HANDLE leaks
- check que tous les xpm existent (== sprites) : images format png (+ redimensionner en pixels - ex : 50x50)
>> mlx new window + mlx file to image

>>> Exit functions
- mlx destroy window 
- mlx destroy display + free
- sprites : mlx destory image
- free()

3. Init structure 
- mlx-init or struct == 0

3. Render
- mlx put image to window
- if char = X put x imge

4. Interactions clavier
- mlx key hook (mettre fonction cree dedans >> code dans cette fonction)
>> mettre touches pour se deplacer dans fonction dans mlx key hook
+ decrementer collectibles quand 1 est pris + check if valid move >> do if is valid

>> Afficher nb de moves
- mlx string put

6. a la fin du main
- mlx loop
- mlx hook (to close window with croix)



// void	my_mlx_pixel_put(t_img *img, int x, int y, int color)
// {
// 	char	*to_fill;

// 	to_fill = img->addr + (y * img->line_length + x * (img->bits_per_pixel
// 				/ 8));
// 	*(unsigned int *)to_fill = color;
// }

// int	display_images(t_game *game)
// {
// 	game->img.img = mlx_new_image(game->mlx, WIDTH, HEIGHT);
// 	game->img.addr = mlx_get_data_addr(game->img.img, &game->img.bits_per_pixel,
// 			&game->img.line_length, &game->img.endian);
// 	my_mlx_pixel_put(&(game->img), 10, 10, RED);
// 	my_mlx_pixel_put(&(game->img), 20, 20, WHITE);
// 	mlx_put_image_to_window(game->mlx, game->win, game->img.img, 0, 0);
// 	return (0);
// }


// void	init_game(char **map, t_lay *lay)
// {
// 	t_game	game;
// 	t_point	size;

// 	size.x = lay->row;
// 	size.y = lay->col;
// 	game.map = copy_map(map, size);
// 	if (!(game.map))
// 		print_error("Memory allocation failed", map, 0);
// 	clear_map(map);
// 	game.lay = lay;
// 	game.mlx = mlx_init();
// 	if (!game.mlx)
// 		print_error("MLX initialization failed.", game.map, 0);
// 	// game.img = init_img(game);
// 	// display_all(game);
// 	game.win = mlx_new_window(game.mlx, HEIGHT, WIDTH, "SO_LONG");
// 	// game.win = 0; // TEST HERE >> CHECK LEAKS
// 	if (!game.win)
// 	{
// 		perror("Error\n");
// 		clear_game(&game);
// 	}

// 	// mlx_loop_hook(game.mlx, &render_map, &game);
	
// 	mlx_hook(game.win, DestroyNotify, StructureNotifyMask, &clear_game, &game);
// 	mlx_hook(game.win, KeyRelease, KeyReleaseMask, &on_keypress, &game);
// 	mlx_loop(game.mlx);
// }


	if (data->map[pos_y - 1][pos_x] != data->content.wall)
	{
		if (!(data->map[pos_y - 1][pos_x] == data->content.exit))
		{
			data->map[pos_y - 1][pos_x] = data->content.player;
			data->map[pos_y][pos_x] = data->content.space;
			data->count += 1;
			printf("count: %d\n", data->count);
		}
		else
		{
			if (chk_collect(data) == 0)
			{
				printf("Felicitation vous avez gagne en : %d coup !\n",
					data->count);
				end(data);
			}
		}
	}
}
